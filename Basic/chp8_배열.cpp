// ● 배열 : 동일 타입 데이터가 여러 개 저장된 메모리
	// 1. 배열 구성
		// 1) 인덱스 : 배열 원소 번호
	// 2. 배열 종류
		// 1) 1차원 배열 : float s[5];
		// 1) 1차원 배열 : double s[5];
			// - 실제론 1차원 구현
		// 2) 2차원 배열 : int s[3][10];
			// - 실제론 1차원 구현 : 1행1열, 1행 2열,..., 2행1열...
			// - 2차원 배열 초기화
				// 수동 배열 크기 지정 : int s[3][5] = {{0, 1, 2, 3, 4}, {10, 11, 12, 13, 14}, {20, 21, 22, 23, 24}};
				// 자동 배열 크기 지정 : int s[][5] = {{0, 1, 2, 3, 4}, {10, 11, 12, 13, 14}, {20, 21, 22, 23, 24}};
				// 자동 2차원 배열 지정 : int s[3][5] = {0, 1, 2, 3, 4, 10, 11, 12, 13, 14, 20, 21, 22, 23, 24}; ♣
				// 자동 나머지 초기값 0 지정 : int s[][5] = {{0, 1, 2}, {10, 11, 12}, {20, 21, 22}}; ♣
		// 3) 3차원 배열 : char s[5][3][10];
			// - 실제론 1차원 구현 : 1행1열1페이지, 1행2열1페이지, ...
	// 3. 배열 사용 순서
		// 1) 배열 선언
			// - 자동 초기값 0 지정 : 자료형 + 배열이름 [배열크기] ♣
			// - 자동 배열크기 지정 : 자료형 + 배열이름 [] = {초기값1, 초기값2...};
			// - 자동 배열크기 지정 + 자동 나머지 초기값 0 지정 : 자료형 + 배열이름 [배열 크기] = {초기값1, 초기값2...}; ♣
		// 2) 잘못된 인덱스 배열 접근
			// - 읽기 : 쓰레기값 추출
			// - 쓰기 : 오류 발생
		// 2) 배열 복사
			// - 배열 통째로 복사 불가 ♣
				// int grade[5];
				// int score[5];
				// score = grade; >> 불가
			// - 배열 원소 하나씩 복사 가능
				// int grade[5];
				// int score[5];
				// for(i=0;i<5;i++)
					// b[i] = a[i]; >> 가능
		// 2) 배열 비교
			// - 배열 통째로 비교 불가 ♣
				// int grade[5];
				// int score[5];
				// score == grade; >> 불가
			// - 배열 원소 하나씩 비교 가능
				// int grade[5];
				// int score[5];
				// for(i=0;i<5;i++)
					// if(b[i] != a[i]) return 0; >> 가능
		// 2) 배열 원소 개수
			// - 배열 통째로 계산 가능
				// grade[] = {1, 2, 3, 4, 5, 6};
				// size = sizeof(grade) / sizeof(grade[0]); >> 배열 원소 개수 자동 계산 ♣
		// 2) 배열 전달
			// - 배열 전체 전달 : 원본 전달
				// const 자료형 배열 >> 변경 금지
			// - 배열 요소 전달 : 복사본 전달
		// 2) 정렬
			// - 선택 정렬 : 최솟값 선택 후 첫 번째 요소와 교환 반복 ♣
			// - 버블 정렬 : 첫 요소부터 다음 요소와 크기 비교 및 교환 반복 ♣
		// 2) 순차 탐색